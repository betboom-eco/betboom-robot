/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace LuckyGame {
  export type UserInfoStruct = {
    user: PromiseOrValue<string>;
    option: PromiseOrValue<BigNumberish>[];
    amount: PromiseOrValue<BigNumberish>;
    blockNumber: PromiseOrValue<BigNumberish>;
    letAmount: PromiseOrValue<BigNumberish>;
    betAmount: PromiseOrValue<BigNumberish>;
    round: PromiseOrValue<BigNumberish>;
    typeGame: PromiseOrValue<BigNumberish>;
    size: PromiseOrValue<BigNumberish>;
    isClaim: PromiseOrValue<boolean>;
  };

  export type UserInfoStructOutput = [
    string,
    BigNumber[],
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    boolean
  ] & {
    user: string;
    option: BigNumber[];
    amount: BigNumber;
    blockNumber: BigNumber;
    letAmount: BigNumber;
    betAmount: BigNumber;
    round: number;
    typeGame: number;
    size: number;
    isClaim: boolean;
  };

  export type NewInfoStruct = {
    user: PromiseOrValue<string>;
    hash: PromiseOrValue<BytesLike>;
    option: PromiseOrValue<BigNumberish>[];
    paid: PromiseOrValue<BigNumberish>;
    amount: PromiseOrValue<BigNumberish>;
    bAmount: PromiseOrValue<BigNumberish>;
    lAmount: PromiseOrValue<BigNumberish>;
    rateF: PromiseOrValue<BigNumberish>;
    typeGame: PromiseOrValue<BigNumberish>;
    size: PromiseOrValue<BigNumberish>;
    isWin: PromiseOrValue<boolean>;
  };

  export type NewInfoStructOutput = [
    string,
    string,
    BigNumber[],
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    boolean
  ] & {
    user: string;
    hash: string;
    option: BigNumber[];
    paid: BigNumber;
    amount: BigNumber;
    bAmount: BigNumber;
    lAmount: BigNumber;
    rateF: BigNumber;
    typeGame: number;
    size: number;
    isWin: boolean;
  };

  export type QUserStruct = {
    hash: PromiseOrValue<BytesLike>;
    oNum: PromiseOrValue<BigNumberish>;
    winNum: PromiseOrValue<BigNumberish>;
    paid: PromiseOrValue<BigNumberish>;
    bAmount: PromiseOrValue<BigNumberish>;
    lAmount: PromiseOrValue<BigNumberish>;
    blockNum: PromiseOrValue<BigNumberish>;
    rateF: PromiseOrValue<BigNumberish>;
    amount: PromiseOrValue<BigNumberish>;
    round: PromiseOrValue<BigNumberish>;
    typeGame: PromiseOrValue<BigNumberish>;
    size: PromiseOrValue<BigNumberish>;
    isWin: PromiseOrValue<boolean>;
    isClaim: PromiseOrValue<boolean>;
  };

  export type QUserStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    boolean,
    boolean
  ] & {
    hash: string;
    oNum: BigNumber;
    winNum: BigNumber;
    paid: BigNumber;
    bAmount: BigNumber;
    lAmount: BigNumber;
    blockNum: BigNumber;
    rateF: BigNumber;
    amount: BigNumber;
    round: number;
    typeGame: number;
    size: number;
    isWin: boolean;
    isClaim: boolean;
  };
}

export interface LuckyGameInterface extends utils.Interface {
  functions: {
    "bNumber1()": FunctionFragment;
    "bNumber2()": FunctionFragment;
    "bet(uint256,uint8,uint256[])": FunctionFragment;
    "betNextRound(uint8,uint256[])": FunctionFragment;
    "bethSetBlockHash(uint256[],bytes32[])": FunctionFragment;
    "blockStartBetTime(uint256)": FunctionFragment;
    "checkBefore(address)": FunctionFragment;
    "checkBet(address,uint256,uint8,uint256[],uint256)": FunctionFragment;
    "checkClaim(address,uint256)": FunctionFragment;
    "checkOption(uint256[])": FunctionFragment;
    "checkRound(address,uint256,uint8,uint256[])": FunctionFragment;
    "checkSet(address,uint256,bytes32)": FunctionFragment;
    "checkSingle(uint256[])": FunctionFragment;
    "checkSize(uint256[])": FunctionFragment;
    "claim()": FunctionFragment;
    "codeID()": FunctionFragment;
    "codeToID(bytes32)": FunctionFragment;
    "coef1()": FunctionFragment;
    "coef2()": FunctionFragment;
    "deci()": FunctionFragment;
    "getBetBHash(uint256)": FunctionFragment;
    "getBetNumInfo(uint256)": FunctionFragment;
    "getBlockContains(uint256)": FunctionFragment;
    "getBlockNum()": FunctionFragment;
    "getCodeToOption(bytes32)": FunctionFragment;
    "getCurrTime()": FunctionFragment;
    "getHash(uint256)": FunctionFragment;
    "getHashBlock(uint256)": FunctionFragment;
    "getHashBlockNum()": FunctionFragment;
    "getHashLastNum(bytes32)": FunctionFragment;
    "getIDToOption(uint256)": FunctionFragment;
    "getNewInfo(uint256)": FunctionFragment;
    "getNoBlockContains(uint256)": FunctionFragment;
    "getNoHashBlock(uint256)": FunctionFragment;
    "getNoHashBlockNum()": FunctionFragment;
    "getOddInfo(uint256)": FunctionFragment;
    "getOddNumInfo(uint256)": FunctionFragment;
    "getOptionCode(uint256[])": FunctionFragment;
    "getRoundInfo(uint256,uint8)": FunctionFragment;
    "getRoundPaid(uint8,uint256,uint256)": FunctionFragment;
    "getTokenAmount(uint256,uint8)": FunctionFragment;
    "getUserInfo(address)": FunctionFragment;
    "idToCode(uint256)": FunctionFragment;
    "isBInArray(uint256,uint256)": FunctionFragment;
    "isCanBet(uint256,uint256)": FunctionFragment;
    "isCodeExist(bytes32)": FunctionFragment;
    "isInArray(uint256,uint256)": FunctionFragment;
    "luckyPool()": FunctionFragment;
    "maxBetAmount()": FunctionFragment;
    "minBetAmount()": FunctionFragment;
    "nftPool()": FunctionFragment;
    "oddNum()": FunctionFragment;
    "oddRoudPaid(uint256,uint8)": FunctionFragment;
    "oddRoundToBetNum(uint256,uint256)": FunctionFragment;
    "operator()": FunctionFragment;
    "owner()": FunctionFragment;
    "radio(uint8)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setBETNum(uint256,uint256)": FunctionFragment;
    "setBetAmount(uint256,uint256)": FunctionFragment;
    "setBlockHash(uint256,bytes32)": FunctionFragment;
    "setLETNum(uint256,uint256,uint256)": FunctionFragment;
    "setNFTPool(address)": FunctionFragment;
    "setOperator(address)": FunctionFragment;
    "setRadio(uint8[],uint256[])": FunctionFragment;
    "setTrigAccount(address)": FunctionFragment;
    "setTrigTime(uint256)": FunctionFragment;
    "totalBetNum()": FunctionFragment;
    "totalBetToOdd(uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "trigAccount()": FunctionFragment;
    "trigTime()": FunctionFragment;
    "updateBet()": FunctionFragment;
    "userBet(address)": FunctionFragment;
    "userBetNumToTotal(address,uint256)": FunctionFragment;
    "userOddToTotal(address,uint256)": FunctionFragment;
    "userTotalBet(uint256,address)": FunctionFragment;
    "winInfo(uint256)": FunctionFragment;
    "zeroHash()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "bNumber1"
      | "bNumber2"
      | "bet"
      | "betNextRound"
      | "bethSetBlockHash"
      | "blockStartBetTime"
      | "checkBefore"
      | "checkBet"
      | "checkClaim"
      | "checkOption"
      | "checkRound"
      | "checkSet"
      | "checkSingle"
      | "checkSize"
      | "claim"
      | "codeID"
      | "codeToID"
      | "coef1"
      | "coef2"
      | "deci"
      | "getBetBHash"
      | "getBetNumInfo"
      | "getBlockContains"
      | "getBlockNum"
      | "getCodeToOption"
      | "getCurrTime"
      | "getHash"
      | "getHashBlock"
      | "getHashBlockNum"
      | "getHashLastNum"
      | "getIDToOption"
      | "getNewInfo"
      | "getNoBlockContains"
      | "getNoHashBlock"
      | "getNoHashBlockNum"
      | "getOddInfo"
      | "getOddNumInfo"
      | "getOptionCode"
      | "getRoundInfo"
      | "getRoundPaid"
      | "getTokenAmount"
      | "getUserInfo"
      | "idToCode"
      | "isBInArray"
      | "isCanBet"
      | "isCodeExist"
      | "isInArray"
      | "luckyPool"
      | "maxBetAmount"
      | "minBetAmount"
      | "nftPool"
      | "oddNum"
      | "oddRoudPaid"
      | "oddRoundToBetNum"
      | "operator"
      | "owner"
      | "radio"
      | "renounceOwnership"
      | "setBETNum"
      | "setBetAmount"
      | "setBlockHash"
      | "setLETNum"
      | "setNFTPool"
      | "setOperator"
      | "setRadio"
      | "setTrigAccount"
      | "setTrigTime"
      | "totalBetNum"
      | "totalBetToOdd"
      | "transferOwnership"
      | "trigAccount"
      | "trigTime"
      | "updateBet"
      | "userBet"
      | "userBetNumToTotal"
      | "userOddToTotal"
      | "userTotalBet"
      | "winInfo"
      | "zeroHash"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "bNumber1", values?: undefined): string;
  encodeFunctionData(functionFragment: "bNumber2", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "bet",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "betNextRound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "bethSetBlockHash",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "blockStartBetTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "checkBefore",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "checkBet",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "checkClaim",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "checkOption",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "checkRound",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "checkSet",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "checkSingle",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "checkSize",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(functionFragment: "claim", values?: undefined): string;
  encodeFunctionData(functionFragment: "codeID", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "codeToID",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "coef1", values?: undefined): string;
  encodeFunctionData(functionFragment: "coef2", values?: undefined): string;
  encodeFunctionData(functionFragment: "deci", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getBetBHash",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBetNumInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBlockContains",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getBlockNum",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCodeToOption",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getHash",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getHashBlock",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getHashBlockNum",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getHashLastNum",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getIDToOption",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNewInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNoBlockContains",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNoHashBlock",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNoHashBlockNum",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOddInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOddNumInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getOptionCode",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoundInfo",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoundPaid",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenAmount",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "idToCode",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isBInArray",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isCanBet",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isCodeExist",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "isInArray",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "luckyPool", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "maxBetAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minBetAmount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "nftPool", values?: undefined): string;
  encodeFunctionData(functionFragment: "oddNum", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "oddRoudPaid",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "oddRoundToBetNum",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "operator", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "radio",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setBETNum",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBetAmount",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBlockHash",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "setLETNum",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setNFTPool",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOperator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRadio",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrigAccount",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrigTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalBetNum",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalBetToOdd",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "trigAccount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "trigTime", values?: undefined): string;
  encodeFunctionData(functionFragment: "updateBet", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "userBet",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "userBetNumToTotal",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "userOddToTotal",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "userTotalBet",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "winInfo",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "zeroHash", values?: undefined): string;

  decodeFunctionResult(functionFragment: "bNumber1", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bNumber2", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bet", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "betNextRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bethSetBlockHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "blockStartBetTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkBefore",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "checkBet", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "checkClaim", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "checkOption",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "checkRound", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "checkSet", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "checkSingle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "checkSize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "codeID", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "codeToID", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "coef1", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "coef2", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "deci", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBetBHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBetNumInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBlockContains",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBlockNum",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCodeToOption",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getHash", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getHashBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHashBlockNum",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHashLastNum",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getIDToOption",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNewInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNoBlockContains",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNoHashBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNoHashBlockNum",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOddInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOddNumInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getOptionCode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoundInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoundPaid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "idToCode", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isBInArray", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isCanBet", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isCodeExist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isInArray", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "luckyPool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "maxBetAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minBetAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nftPool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "oddNum", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "oddRoudPaid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "oddRoundToBetNum",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "operator", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "radio", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setBETNum", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBetAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBlockHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setLETNum", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setNFTPool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setOperator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setRadio", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setTrigAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTrigTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalBetNum",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalBetToOdd",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trigAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "trigTime", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "updateBet", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "userBet", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "userBetNumToTotal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userOddToTotal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userTotalBet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "winInfo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "zeroHash", data: BytesLike): Result;

  events: {
    "Bet(address,uint256,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "Claim(uint256,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "SetBlockHash(uint256,uint256,bytes32)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Bet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Claim"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetBlockHash"): EventFragment;
}

export interface BetEventObject {
  user: string;
  amount: BigNumber;
  oddID: BigNumber;
  betID: BigNumber;
  oddNum: BigNumber;
  betNum: BigNumber;
  round: BigNumber;
}
export type BetEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber],
  BetEventObject
>;

export type BetEventFilter = TypedEventFilter<BetEvent>;

export interface ClaimEventObject {
  userBetOddNum: BigNumber;
  amount: BigNumber;
}
export type ClaimEvent = TypedEvent<[BigNumber, BigNumber], ClaimEventObject>;

export type ClaimEventFilter = TypedEventFilter<ClaimEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface SetBlockHashEventObject {
  blm: BigNumber;
  winNum: BigNumber;
  hash: string;
}
export type SetBlockHashEvent = TypedEvent<
  [BigNumber, BigNumber, string],
  SetBlockHashEventObject
>;

export type SetBlockHashEventFilter = TypedEventFilter<SetBlockHashEvent>;

export interface LuckyGame extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LuckyGameInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    bNumber1(overrides?: CallOverrides): Promise<[BigNumber]>;

    bNumber2(overrides?: CallOverrides): Promise<[BigNumber]>;

    bet(
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    betNextRound(
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    bethSetBlockHash(
      blms: PromiseOrValue<BigNumberish>[],
      hashs: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    blockStartBetTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    checkBefore(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, string, BigNumber, BigNumber] & {
        isWin: boolean;
        hash: string;
        winNum: BigNumber;
        paid: BigNumber;
      }
    >;

    checkBet(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      pAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, number]>;

    checkClaim(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber]>;

    checkOption(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    checkRound(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { hash: string; num: BigNumber }>;

    checkSet(
      account: PromiseOrValue<string>,
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    checkSingle(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[number]>;

    checkSize(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[number]>;

    claim(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    codeID(overrides?: CallOverrides): Promise<[BigNumber]>;

    codeToID(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    coef1(overrides?: CallOverrides): Promise<[BigNumber]>;

    coef2(overrides?: CallOverrides): Promise<[BigNumber]>;

    deci(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBetBHash(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { hash: string }>;

    getBetNumInfo(
      betNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[LuckyGame.UserInfoStructOutput]>;

    getBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getBlockNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCodeToOption(
      code: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getCurrTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    getHash(
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { hash: string }>;

    getHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getHashBlockNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    getHashLastNum(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getIDToOption(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getNewInfo(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [LuckyGame.NewInfoStructOutput] & {
        newInfo: LuckyGame.NewInfoStructOutput;
      }
    >;

    getNoBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getNoHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getNoHashBlockNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    getOddInfo(
      oddNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[LuckyGame.UserInfoStructOutput]>;

    getOddNumInfo(
      oNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [LuckyGame.QUserStructOutput, BigNumber[]] & {
        quser: LuckyGame.QUserStructOutput;
        option: BigNumber[];
      }
    >;

    getOptionCode(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[string]>;

    getRoundInfo(
      oNum: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [LuckyGame.QUserStructOutput, BigNumber[]] & {
        quser: LuckyGame.QUserStructOutput;
        option: BigNumber[];
      }
    >;

    getRoundPaid(
      round: PromiseOrValue<BigNumberish>,
      len: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getTokenAmount(
      amount: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [LuckyGame.QUserStructOutput, BigNumber[]] & {
        quser: LuckyGame.QUserStructOutput;
        option: BigNumber[];
      }
    >;

    idToCode(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    isBInArray(
      winNum: PromiseOrValue<BigNumberish>,
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isCanBet(
      paid: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isCodeExist(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isInArray(
      winNum: PromiseOrValue<BigNumberish>,
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    luckyPool(overrides?: CallOverrides): Promise<[string]>;

    maxBetAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    minBetAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    nftPool(overrides?: CallOverrides): Promise<[string]>;

    oddNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    oddRoudPaid(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    oddRoundToBetNum(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    operator(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    radio(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBetAmount(
      min: PromiseOrValue<BigNumberish>,
      max: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBlockHash(
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setLETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      num3: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setNFTPool(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOperator(
      operator_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRadio(
      round: PromiseOrValue<BigNumberish>[],
      radios: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTrigAccount(
      addr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTrigTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    totalBetNum(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalBetToOdd(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    trigAccount(overrides?: CallOverrides): Promise<[string]>;

    trigTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    updateBet(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    userBet(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { betOddNum: BigNumber; betNum: BigNumber }
    >;

    userBetNumToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    userOddToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    userTotalBet(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    winInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, number, number] & {
        blockHash: string;
        winNumber: BigNumber;
        sizeBS: number;
        sizeSD: number;
      }
    >;

    zeroHash(overrides?: CallOverrides): Promise<[string]>;
  };

  bNumber1(overrides?: CallOverrides): Promise<BigNumber>;

  bNumber2(overrides?: CallOverrides): Promise<BigNumber>;

  bet(
    amount: PromiseOrValue<BigNumberish>,
    tGame: PromiseOrValue<BigNumberish>,
    option: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  betNextRound(
    tGame: PromiseOrValue<BigNumberish>,
    option: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  bethSetBlockHash(
    blms: PromiseOrValue<BigNumberish>[],
    hashs: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  blockStartBetTime(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  checkBefore(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, string, BigNumber, BigNumber] & {
      isWin: boolean;
      hash: string;
      winNum: BigNumber;
      paid: BigNumber;
    }
  >;

  checkBet(
    user: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    tGame: PromiseOrValue<BigNumberish>,
    option: PromiseOrValue<BigNumberish>[],
    pAmount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, number]>;

  checkClaim(
    user: PromiseOrValue<string>,
    userBetOddNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[string, BigNumber]>;

  checkOption(
    option: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  checkRound(
    user: PromiseOrValue<string>,
    userBetOddNum: PromiseOrValue<BigNumberish>,
    tGame: PromiseOrValue<BigNumberish>,
    option: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<[string, BigNumber] & { hash: string; num: BigNumber }>;

  checkSet(
    account: PromiseOrValue<string>,
    blm: PromiseOrValue<BigNumberish>,
    hash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  checkSingle(
    option: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<number>;

  checkSize(
    option: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<number>;

  claim(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  codeID(overrides?: CallOverrides): Promise<BigNumber>;

  codeToID(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  coef1(overrides?: CallOverrides): Promise<BigNumber>;

  coef2(overrides?: CallOverrides): Promise<BigNumber>;

  deci(overrides?: CallOverrides): Promise<BigNumber>;

  getBetBHash(
    betNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getBetNumInfo(
    betNum_: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<LuckyGame.UserInfoStructOutput>;

  getBlockContains(
    blm: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

  getCodeToOption(
    code: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getCurrTime(overrides?: CallOverrides): Promise<BigNumber>;

  getHash(
    oddID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getHashBlock(
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getHashBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

  getHashLastNum(
    hash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getIDToOption(
    id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getNewInfo(
    betNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<LuckyGame.NewInfoStructOutput>;

  getNoBlockContains(
    blm: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getNoHashBlock(
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber]>;

  getNoHashBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

  getOddInfo(
    oddNum_: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<LuckyGame.UserInfoStructOutput>;

  getOddNumInfo(
    oNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [LuckyGame.QUserStructOutput, BigNumber[]] & {
      quser: LuckyGame.QUserStructOutput;
      option: BigNumber[];
    }
  >;

  getOptionCode(
    option: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<string>;

  getRoundInfo(
    oNum: PromiseOrValue<BigNumberish>,
    round: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [LuckyGame.QUserStructOutput, BigNumber[]] & {
      quser: LuckyGame.QUserStructOutput;
      option: BigNumber[];
    }
  >;

  getRoundPaid(
    round: PromiseOrValue<BigNumberish>,
    len: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTokenAmount(
    amount: PromiseOrValue<BigNumberish>,
    round: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber]>;

  getUserInfo(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [LuckyGame.QUserStructOutput, BigNumber[]] & {
      quser: LuckyGame.QUserStructOutput;
      option: BigNumber[];
    }
  >;

  idToCode(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  isBInArray(
    winNum: PromiseOrValue<BigNumberish>,
    betNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isCanBet(
    paid: PromiseOrValue<BigNumberish>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isCodeExist(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isInArray(
    winNum: PromiseOrValue<BigNumberish>,
    oddID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  luckyPool(overrides?: CallOverrides): Promise<string>;

  maxBetAmount(overrides?: CallOverrides): Promise<BigNumber>;

  minBetAmount(overrides?: CallOverrides): Promise<BigNumber>;

  nftPool(overrides?: CallOverrides): Promise<string>;

  oddNum(overrides?: CallOverrides): Promise<BigNumber>;

  oddRoudPaid(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  oddRoundToBetNum(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  operator(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  radio(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBETNum(
    num1: PromiseOrValue<BigNumberish>,
    num2: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBetAmount(
    min: PromiseOrValue<BigNumberish>,
    max: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBlockHash(
    blm: PromiseOrValue<BigNumberish>,
    hash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setLETNum(
    num1: PromiseOrValue<BigNumberish>,
    num2: PromiseOrValue<BigNumberish>,
    num3: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setNFTPool(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOperator(
    operator_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRadio(
    round: PromiseOrValue<BigNumberish>[],
    radios: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTrigAccount(
    addr: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTrigTime(
    time: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  totalBetNum(overrides?: CallOverrides): Promise<BigNumber>;

  totalBetToOdd(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  trigAccount(overrides?: CallOverrides): Promise<string>;

  trigTime(overrides?: CallOverrides): Promise<BigNumber>;

  updateBet(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  userBet(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { betOddNum: BigNumber; betNum: BigNumber }
  >;

  userBetNumToTotal(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  userOddToTotal(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  userTotalBet(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  winInfo(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, number, number] & {
      blockHash: string;
      winNumber: BigNumber;
      sizeBS: number;
      sizeSD: number;
    }
  >;

  zeroHash(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    bNumber1(overrides?: CallOverrides): Promise<BigNumber>;

    bNumber2(overrides?: CallOverrides): Promise<BigNumber>;

    bet(
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    betNextRound(
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    bethSetBlockHash(
      blms: PromiseOrValue<BigNumberish>[],
      hashs: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    blockStartBetTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkBefore(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, string, BigNumber, BigNumber] & {
        isWin: boolean;
        hash: string;
        winNum: BigNumber;
        paid: BigNumber;
      }
    >;

    checkBet(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      pAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, number]>;

    checkClaim(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string, BigNumber]>;

    checkOption(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    checkRound(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[string, BigNumber] & { hash: string; num: BigNumber }>;

    checkSet(
      account: PromiseOrValue<string>,
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    checkSingle(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<number>;

    checkSize(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<number>;

    claim(overrides?: CallOverrides): Promise<void>;

    codeID(overrides?: CallOverrides): Promise<BigNumber>;

    codeToID(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    coef1(overrides?: CallOverrides): Promise<BigNumber>;

    coef2(overrides?: CallOverrides): Promise<BigNumber>;

    deci(overrides?: CallOverrides): Promise<BigNumber>;

    getBetBHash(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getBetNumInfo(
      betNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<LuckyGame.UserInfoStructOutput>;

    getBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

    getCodeToOption(
      code: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getCurrTime(overrides?: CallOverrides): Promise<BigNumber>;

    getHash(
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHashBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

    getHashLastNum(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIDToOption(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getNewInfo(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<LuckyGame.NewInfoStructOutput>;

    getNoBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getNoHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getNoHashBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

    getOddInfo(
      oddNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<LuckyGame.UserInfoStructOutput>;

    getOddNumInfo(
      oNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [LuckyGame.QUserStructOutput, BigNumber[]] & {
        quser: LuckyGame.QUserStructOutput;
        option: BigNumber[];
      }
    >;

    getOptionCode(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<string>;

    getRoundInfo(
      oNum: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [LuckyGame.QUserStructOutput, BigNumber[]] & {
        quser: LuckyGame.QUserStructOutput;
        option: BigNumber[];
      }
    >;

    getRoundPaid(
      round: PromiseOrValue<BigNumberish>,
      len: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenAmount(
      amount: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [LuckyGame.QUserStructOutput, BigNumber[]] & {
        quser: LuckyGame.QUserStructOutput;
        option: BigNumber[];
      }
    >;

    idToCode(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    isBInArray(
      winNum: PromiseOrValue<BigNumberish>,
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isCanBet(
      paid: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isCodeExist(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isInArray(
      winNum: PromiseOrValue<BigNumberish>,
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    luckyPool(overrides?: CallOverrides): Promise<string>;

    maxBetAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minBetAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nftPool(overrides?: CallOverrides): Promise<string>;

    oddNum(overrides?: CallOverrides): Promise<BigNumber>;

    oddRoudPaid(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oddRoundToBetNum(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    operator(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    radio(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setBETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBetAmount(
      min: PromiseOrValue<BigNumberish>,
      max: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBlockHash(
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setLETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      num3: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setNFTPool(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOperator(
      operator_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRadio(
      round: PromiseOrValue<BigNumberish>[],
      radios: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    setTrigAccount(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTrigTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    totalBetNum(overrides?: CallOverrides): Promise<BigNumber>;

    totalBetToOdd(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    trigAccount(overrides?: CallOverrides): Promise<string>;

    trigTime(overrides?: CallOverrides): Promise<BigNumber>;

    updateBet(overrides?: CallOverrides): Promise<void>;

    userBet(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { betOddNum: BigNumber; betNum: BigNumber }
    >;

    userBetNumToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userOddToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userTotalBet(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    winInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, number, number] & {
        blockHash: string;
        winNumber: BigNumber;
        sizeBS: number;
        sizeSD: number;
      }
    >;

    zeroHash(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "Bet(address,uint256,uint256,uint256,uint256,uint256,uint256)"(
      user?: null,
      amount?: null,
      oddID?: null,
      betID?: null,
      oddNum?: null,
      betNum?: null,
      round?: null
    ): BetEventFilter;
    Bet(
      user?: null,
      amount?: null,
      oddID?: null,
      betID?: null,
      oddNum?: null,
      betNum?: null,
      round?: null
    ): BetEventFilter;

    "Claim(uint256,uint256)"(
      userBetOddNum?: null,
      amount?: null
    ): ClaimEventFilter;
    Claim(userBetOddNum?: null, amount?: null): ClaimEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "SetBlockHash(uint256,uint256,bytes32)"(
      blm?: null,
      winNum?: null,
      hash?: null
    ): SetBlockHashEventFilter;
    SetBlockHash(
      blm?: null,
      winNum?: null,
      hash?: null
    ): SetBlockHashEventFilter;
  };

  estimateGas: {
    bNumber1(overrides?: CallOverrides): Promise<BigNumber>;

    bNumber2(overrides?: CallOverrides): Promise<BigNumber>;

    bet(
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    betNextRound(
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    bethSetBlockHash(
      blms: PromiseOrValue<BigNumberish>[],
      hashs: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    blockStartBetTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkBefore(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkBet(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      pAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkClaim(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkOption(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkRound(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkSet(
      account: PromiseOrValue<string>,
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkSingle(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkSize(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claim(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    codeID(overrides?: CallOverrides): Promise<BigNumber>;

    codeToID(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    coef1(overrides?: CallOverrides): Promise<BigNumber>;

    coef2(overrides?: CallOverrides): Promise<BigNumber>;

    deci(overrides?: CallOverrides): Promise<BigNumber>;

    getBetBHash(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBetNumInfo(
      betNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

    getCodeToOption(
      code: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrTime(overrides?: CallOverrides): Promise<BigNumber>;

    getHash(
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHashBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

    getHashLastNum(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIDToOption(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNewInfo(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNoBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNoHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNoHashBlockNum(overrides?: CallOverrides): Promise<BigNumber>;

    getOddInfo(
      oddNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOddNumInfo(
      oNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getOptionCode(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoundInfo(
      oNum: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoundPaid(
      round: PromiseOrValue<BigNumberish>,
      len: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTokenAmount(
      amount: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    idToCode(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBInArray(
      winNum: PromiseOrValue<BigNumberish>,
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isCanBet(
      paid: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isCodeExist(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isInArray(
      winNum: PromiseOrValue<BigNumberish>,
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    luckyPool(overrides?: CallOverrides): Promise<BigNumber>;

    maxBetAmount(overrides?: CallOverrides): Promise<BigNumber>;

    minBetAmount(overrides?: CallOverrides): Promise<BigNumber>;

    nftPool(overrides?: CallOverrides): Promise<BigNumber>;

    oddNum(overrides?: CallOverrides): Promise<BigNumber>;

    oddRoudPaid(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oddRoundToBetNum(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    operator(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    radio(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBetAmount(
      min: PromiseOrValue<BigNumberish>,
      max: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBlockHash(
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setLETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      num3: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setNFTPool(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOperator(
      operator_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRadio(
      round: PromiseOrValue<BigNumberish>[],
      radios: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTrigAccount(
      addr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTrigTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    totalBetNum(overrides?: CallOverrides): Promise<BigNumber>;

    totalBetToOdd(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    trigAccount(overrides?: CallOverrides): Promise<BigNumber>;

    trigTime(overrides?: CallOverrides): Promise<BigNumber>;

    updateBet(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    userBet(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userBetNumToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userOddToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userTotalBet(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    winInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    zeroHash(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    bNumber1(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bNumber2(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bet(
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    betNextRound(
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    bethSetBlockHash(
      blms: PromiseOrValue<BigNumberish>[],
      hashs: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    blockStartBetTime(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkBefore(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkBet(
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      pAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkClaim(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkOption(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkRound(
      user: PromiseOrValue<string>,
      userBetOddNum: PromiseOrValue<BigNumberish>,
      tGame: PromiseOrValue<BigNumberish>,
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkSet(
      account: PromiseOrValue<string>,
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkSingle(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkSize(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claim(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    codeID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    codeToID(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    coef1(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    coef2(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deci(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBetBHash(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBetNumInfo(
      betNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBlockNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCodeToOption(
      code: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getHash(
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getHashBlockNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getHashLastNum(
      hash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getIDToOption(
      id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNewInfo(
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNoBlockContains(
      blm: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNoHashBlock(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNoHashBlockNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getOddInfo(
      oddNum_: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOddNumInfo(
      oNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getOptionCode(
      option: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoundInfo(
      oNum: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoundPaid(
      round: PromiseOrValue<BigNumberish>,
      len: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTokenAmount(
      amount: PromiseOrValue<BigNumberish>,
      round: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    idToCode(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBInArray(
      winNum: PromiseOrValue<BigNumberish>,
      betNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isCanBet(
      paid: PromiseOrValue<BigNumberish>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isCodeExist(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isInArray(
      winNum: PromiseOrValue<BigNumberish>,
      oddID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    luckyPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxBetAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minBetAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nftPool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    oddNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    oddRoudPaid(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oddRoundToBetNum(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    operator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    radio(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBetAmount(
      min: PromiseOrValue<BigNumberish>,
      max: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBlockHash(
      blm: PromiseOrValue<BigNumberish>,
      hash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setLETNum(
      num1: PromiseOrValue<BigNumberish>,
      num2: PromiseOrValue<BigNumberish>,
      num3: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setNFTPool(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOperator(
      operator_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRadio(
      round: PromiseOrValue<BigNumberish>[],
      radios: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTrigAccount(
      addr: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTrigTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    totalBetNum(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalBetToOdd(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    trigAccount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    trigTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateBet(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    userBet(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userBetNumToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userOddToTotal(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userTotalBet(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    winInfo(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    zeroHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
